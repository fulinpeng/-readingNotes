<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // Function.prototype === Function.__proto__
        // 并不是说 Function 的构造函数是自己
        // Function.prototype 是一个函数，这个函数是引擎自己创建的，而且它没有prototype属性
        // Function.prototype.prototype === undefined

        // 所有对象都可以通过原型链最终找到 Object.prototype ，虽然 Object.prototype 
        // 也是一个对象，但是这个对象却不是 Object 创造的，而是引擎自己创建了 Object.prototype 。
        // 所以可以这样说，所有实例都是对象，但是对象不一定都是实例。
        
        // 首先引擎创建了 Object.prototype ，然后创建了 Function.prototype ，并且通过 __proto__ 
        // 将两者联系了起来：Function.prototype.__proto__ = Object.prototype
        // 这里也很好的解释了上面的一个问题，为什么 let fun = Function.prototype.bind()
        // 没有 prototype 属性，Function.prototype没有prototype属性。因为 Function.prototype 
        // 是引擎创建出来的对象，引擎认为不需要给这个对象添加 prototype 属性。

        // 所以我们又可以得出一个结论，不是所有函数都是 new Function() 产生的。

        // 有了 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的
        
        // 先有 Object.prototype 并且 它的 __proto__ 为 null
        // 然后才 Function.prototype 为特殊函数
        // 并且赋值 Function.prototype = undefined
        // 并且和Object用__proto__链接起来 Function.prototype.__proto__ = Object.prototype
        // 此时所得到的 Function才是我们看到的怪异的大 Function







        // 可能是为了与其他函数风格保持一致，所以内部让 Function.__proto__ = Function.prototype
        // 所以 Function.prototype === Function.__proto__ 就像自己创建了自己

        // Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它
        // Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它
        // Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建
        // 函数的 prototype 是一个对象，也就是原型
        // 对象的 __proto__ 指向原型， __proto__ 将对象和原型连接起来组成了原型链
    
    </script>
</body>
</html>